use chrono::NaiveDateTime;
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

/// Represents a debt record in the database.
///
/// # Fields
/// - `debt_id`: Unique identifier for the debt record.
/// - `customer_id`: The ID of the customer associated with the debt.
/// - `amount`: The total amount of the debt.
/// - `customer_date`: The date when the debt was incurred.
/// - `paid_date`: The date when the debt was paid. This field is `None` if the debt is not paid yet.
/// - `is_paid`: A boolean indicating whether the debt has been paid or not.
#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct Debt {
    pub debt_id: i32,
    pub customer_id: i32,
    pub amount: i32,
    pub customer_date: NaiveDateTime,
    pub paid_date: Option<NaiveDateTime>,
    pub is_paid: bool,
}

/// Constructs a new `Debt` instance.
///
/// # Arguments
///
/// * `customer_id` - The ID of the customer associated with the debt.
/// * `amount` - The total amount of the debt.
/// * `customer_date` - The date when the debt was incurred.
/// * `paid_date` - The date when the debt was paid. If the debt has not been paid, this should be `None`.
/// * `is_paid` - A boolean indicating whether the debt has been paid or not.
///
/// # Returns
///
/// A `Debt` instance with `debt_id` set to `0`. This ID is typically generated by the database upon insertion.
///
/// # Examples
///
/// ```rust
/// use crate::models::Debt;
/// use chrono::NaiveDateTime;
///
/// let customer_date = NaiveDateTime::parse_from_str("2024-08-01 12:00:00", "%Y-%m-%d %H:%M:%S").unwrap();
/// let paid_date = None; // Or `Some(NaiveDateTime::parse_from_str("2024-08-02 15:30:00", "%Y-%m-%d %H:%M:%S").unwrap())`
///
/// let debt = build_debt(
///     1,
///     1000,
///     customer_date,
///     paid_date,
///     false,
/// );
///
/// assert_eq!(debt.customer_id, 1);
/// assert_eq!(debt.amount, 1000);
/// assert_eq!(debt.is_paid, false);
/// ```
///
/// # Notes
/// - The `debt_id` field is initialized to `0` and should be updated with a value assigned by the database after insertion.
pub fn build_debt(customer_id: i32, amount: i32, customer_date: NaiveDateTime, paid_date: Option<NaiveDateTime>, is_paid: bool) -> Debt {
    Debt {
        debt_id: 0,
        customer_id,
        amount,
        customer_date,
        paid_date,
        is_paid,
    }
}
